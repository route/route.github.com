<!DOCTYPE html>
<html>
  <head>
    <title>Rails autoloading</title>
    <meta charset='utf-8' />
    <link href="/stylesheets/application.css" media="screen" rel="stylesheet" type="text/css" />
    <script src="/javascripts/application.js" type="text/javascript"></script>
  </head>
  <body>
    <div class='content'>
      <header>
        <a href="/">Blog</a>
      </header>
      <article>
  <h1>Rails autoloading</h1>
  <time>November  8, 2013</time>
  <h2>Rails</h2>

<p>There is much to be said about Rails autoloading and particularly about
<code>ActiveSupport::Dependencies</code> (<code>AS::D</code> for short). First off, why do we need it?
Because it&#39;s conveniently! We don&#39;t have to write in every single file
<code>require</code>. Rails loads constants and watches what we need automatically. We&#39;ve
been doing it for so long that I can&#39;t even imagine my life without <code>AS::D</code>.
There are some pitfalls of using it that you must know, but when you learn them
your life will be easier, belive me.</p>

<p>Priviously discussed method <code>self.const_missing(const_name)</code> is an entry point
where <code>AS::D</code> starts doing its job. Let&#39;s try this example:</p>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="c1"># /autoloadable/a.rb</span>
  <span class="c1"># module A</span>
  <span class="c1"># end</span>

  <span class="nb">require</span> <span class="s1">&#39;active_support/dependencies&#39;</span>
  <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Dependencies</span><span class="o">.</span><span class="n">autoload_paths</span> <span class="o">=</span> <span class="o">[</span><span class="s1">&#39;/autoloadable&#39;</span><span class="o">]</span>

  <span class="n">A</span>
</pre></div>
</td></tr></table></div>
<p>Doing this <code>AS::D</code> loads for you module <code>A</code> automatically without any <code>require</code>.
Let&#39;s dig dipper and know how it actually works. There are two different
constant autoloading schemas by name: <code>:require</code> and <code>:load</code>. The first one
means that all the constants won&#39;t be reloaded(as eventually <code>require</code> does,
do you remember <code>$LOADED_FEATURES</code>?) and the last means all the constants will
be removed from memory and loaded again on demand. We are talking about such
thing as &#39;removing constant from memory&#39;, it&#39;d be very useful to know how.
There&#39;s a method called <code>Module#remove_const(sym)</code>:</p>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="k">module</span> <span class="nn">A</span><span class="p">;</span> <span class="k">end</span>
  <span class="no">Object</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:remove_const</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
  <span class="n">A</span> <span class="c1"># =&gt; uninitialized constant A (NameError)</span>
</pre></div>
</td></tr></table></div>
<p>But what if we remove constant for existed instance of class:</p>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="k">class</span> <span class="nc">A</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">value</span>
      <span class="s1">&#39;value&#39;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">new</span>
  <span class="no">Object</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:remove_const</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">class</span> <span class="c1"># =&gt; A</span>
  <span class="n">a</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">value</span> <span class="c1"># =&gt; &#39;value&#39;</span>
  <span class="n">A</span> <span class="c1"># =&gt; uninitialized constant A (NameError)</span>
</pre></div>
</td></tr></table></div>
<p>That&#39;s interesting because constant name was removed from memory but its
instance still shows us its class and we can even call class methods on it. It
turns out that this method only removes constant name from <code>Object</code> but the
class as object(Do you still remember that class is an object and a constant is
a variable referencing that object?) still exists in the memory. Ok, move on.</p>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="nb">require</span> <span class="s1">&#39;active_support/dependencies&#39;</span>

  <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Dependencies</span><span class="o">.</span><span class="n">mechanism</span> <span class="o">=</span> <span class="ss">:load</span>
  <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Dependencies</span><span class="o">.</span><span class="n">autoload_paths</span> <span class="o">=</span> <span class="o">[</span><span class="s1">&#39;/autoloadable&#39;</span><span class="o">]</span>
</pre></div>
</td></tr></table></div>
<p>On your first require <code>AS::D</code> includes a few modules into basic ruby classes:
<code>Object</code> and <code>Module</code>. Methods injected into <code>Object</code> overwrite methods like
<code>load</code> and <code>require</code> in order to monitor new emerging constants. Methods in
<code>Module</code> in order to define an entry point <code>const_missing</code>.</p>

<p>Since ruby passes just one argument (const_name) we don&#39;t have an
idea about the context. Example (I&#39;ll skip <code>AS::D</code> initialization in all
subsequent exapmles and will do it where it really needs to be mentioned):</p>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="c1"># /autoloadable/b.rb</span>
  <span class="k">module</span> <span class="nn">B</span>
  <span class="k">end</span>

  <span class="c1"># /autoloadable/a.rb</span>
  <span class="k">module</span> <span class="nn">A</span>
    <span class="n">B</span> <span class="c1"># =&gt; B</span>
  <span class="k">end</span>
</pre></div>
</td></tr></table></div>
<p>Works as expected, another example then:</p>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="c1"># /autoloadable/a.rb</span>
  <span class="k">module</span> <span class="nn">A</span>
  <span class="k">end</span>

  <span class="c1"># /autoloadable/b.rb</span>
  <span class="k">module</span> <span class="nn">B</span>
  <span class="k">end</span>

  <span class="nb">p</span> <span class="n">A</span><span class="o">::</span><span class="n">B</span> <span class="c1"># =&gt; B</span>
</pre></div>
</td></tr></table></div>
<p>Is that right? I don&#39;t think so. If we used pure ruby it would raise
<code>NameError: uninitialized constant A::B</code> because we precisely saying we need
<code>B</code> inside <code>A</code> but not top level <code>B</code>. But it&#39;s a ruby blame it passes such a
scant info to <code>const_missing</code> and <code>AS::D</code> can do nothing with it. As you can see
there are conventions that we have to know if we don&#39;t want to get in trouble.</p>

<h3>Known errors</h3>

<ul>
<li>Toplevel constant B referenced by A::B</li>
</ul>

<p>Have you ever seen the &ldquo;warning: toplevel constant B referenced by A::B&rdquo;? It&#39;s
easy to reproduce without Rails:</p>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="k">class</span> <span class="nc">B</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">class</span> <span class="nc">A</span><span class="p">;</span> <span class="k">end</span>

  <span class="n">A</span><span class="o">::</span><span class="n">B</span>
</pre></div>
</td></tr></table></div>
<p>Since <code>A.ancestors</code> is <code>[A, Object, Kernel, BasicObject]</code> and contains class
<code>Object</code> and <code>B</code> is already defined as a top level constant (saying that we mean
<code>Object::B</code>) ruby shows us warning that constant we&#39;re trying to resolve inside
<code>A</code> references top level constant. Notice that for modules the situation is
different:</p>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="k">module</span> <span class="nn">B</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">module</span> <span class="nn">A</span><span class="p">;</span> <span class="k">end</span>

  <span class="n">A</span><span class="o">::</span><span class="n">B</span>
</pre></div>
</td></tr></table></div>
<p>It gives us just &ldquo;uninitialized constant A::B (NameError)&rdquo; as expected because
the ancestors chain doesn&#39;t contain an <code>Object</code>.</p>

<ul>
<li>Circular dependency detected while autoloading constant</li>
</ul>

<p>This is yet another rails error that you could see. What does this mean and when
it happens? Consider this example:</p>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="c1"># a.rb</span>
  <span class="n">B</span>
  <span class="k">module</span> <span class="nn">A</span>
  <span class="k">end</span>

  <span class="c1"># b.rb</span>
  <span class="n">A</span>
  <span class="k">module</span> <span class="nn">B</span>
  <span class="k">end</span>
</pre></div>
</td></tr></table></div>
<p>If we try to access <code>A</code> constant we&#39;ll see this error. Rails makes an  assumption
that this constant is defined in file <code>a.rb</code>. When it tries to load this file it
faces another undefined constant <code>B</code> and this time trying to load file <code>b.rb</code>
faces again still undefined <code>A</code>. This generates endless recursion and to prevent
it the error should be raised.</p>

<ul>
<li>Multi threaded environment</li>
</ul>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="n">logger</span> <span class="o">=</span> <span class="no">Logger</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="no">STDOUT</span><span class="p">)</span>
  <span class="n">logger</span><span class="o">.</span><span class="n">formatter</span> <span class="o">=</span> <span class="nb">proc</span> <span class="k">do</span> <span class="o">|</span><span class="n">severity</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="n">msg</span><span class="o">|</span>
    <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Thread</span><span class="o">.</span><span class="n">current</span><span class="si">}</span><span class="s2"> = </span><span class="si">#{</span><span class="n">msg</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
  <span class="k">end</span>
  <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Dependencies</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
  <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Dependencies</span><span class="o">.</span><span class="n">log_activity</span> <span class="o">=</span> <span class="kp">true</span>

  <span class="n">t1</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="n">A</span> <span class="p">}</span>
  <span class="n">t2</span> <span class="o">=</span> <span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="p">{</span> <span class="n">A</span> <span class="p">}</span>

  <span class="n">t1</span><span class="o">.</span><span class="n">join</span>
  <span class="n">t2</span><span class="o">.</span><span class="n">join</span>
</pre></div>
</td></tr></table></div>
<p>Will produce this:</p>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="c">#&lt;Thread:0x007fa369cafeb8&gt; = Dependencies: called load_missing_constant(Object, :A)</span>
  <span class="c">#&lt;Thread:0x007fa369cafeb8&gt; = Dependencies: called require_or_load(&quot;dependencies/first/a&quot;, &quot;A&quot;)</span>
  <span class="c">#&lt;Thread:0x007fa369cafeb8&gt; = Dependencies: loading dependencies/first/a</span>
  <span class="c">#&lt;Thread:0x007fa369cafeb8&gt; = Dependencies: called load_file(&quot;dependencies/first/a.rb&quot;, &quot;A&quot;)</span>
  <span class="c">#&lt;Thread:0x007fa369caf968&gt; = Dependencies: called load_missing_constant(Object, :A)</span>

  <span class="c"># A bunch of different errors is waiting for you:</span>
  <span class="c"># =&gt; Circular dependency detected while autoloading constant A</span>
  <span class="c"># =&gt; Unable to autoload constant A, expected dependencies/first/a.rb to define it</span>
  <span class="c"># =&gt; Object is not missing constant A!</span>
</pre></div>
</td></tr></table></div>
<p>Constant autoloading definitely is not thread safe operation, that&#39;s why your
production environment loads all your constants on initialization step. What&#39;s
happend here? In fact you can see all these errors even on MRI because it
switches threads on IO/Sockets. For instance circular dependency arises when
first thread waits for IO and another thread starts constant resolving for the
same constant which is already in a list of loaded.</p>

<ul>
<li>A copy of A has been removed from the module tree but is still active!</li>
</ul>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="k">class</span> <span class="nc">Customer</span>
    <span class="k">def</span> <span class="nf">money</span>
      <span class="no">Money</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="vi">@amount</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">customer</span> <span class="o">=</span> <span class="no">Customer</span><span class="o">.</span><span class="n">new</span>

  <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Dependencies</span><span class="o">.</span><span class="n">clear</span>

  <span class="n">customer</span><span class="o">.</span><span class="n">money</span>
</pre></div>
</td></tr></table></div>
<h3>Don&#39;t do this</h3>

<ul>
<li><p>Giving the same name for both constants - top level and namespaced gives you
<code>Toplevel constant B referenced by A::B</code></p></li>
<li><p>If you have a strange idea that defining constant in two different paths would
make eager loading to load both files you&#39;re wrong. An example:</p></li>
</ul>
<div class='codeblock'><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="c1"># Assuming that AS::D.autoload_paths is [&#39;/first&#39;, &#39;/second&#39;]</span>

  <span class="c1"># /first/a.rb</span>
  <span class="k">module</span> <span class="nn">A</span>
    <span class="k">def</span> <span class="nf">first</span>
      <span class="s1">&#39;first&#39;</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># /second/a.rb</span>
  <span class="k">module</span> <span class="nn">A</span>
    <span class="k">def</span> <span class="nf">second</span>
      <span class="s1">&#39;second&#39;</span>
    <span class="k">end</span>
  <span class="k">end</span>
</pre></div>
</td></tr></table></div>
<p>The last one will never be loaded, since <code>AS::D.search_for_file(&#39;a&#39;)</code> always
returns just first file.</p>

<h3>Conclusion</h3>

<p>You don&#39;t have to care about all these stuff if you have flat model, it means
when you don&#39;t use namespaces and all the files have different names, but it&#39;s
hard if you have a lot of classes/modules (that&#39;s another reason why modules
were invented). And you must have clear understanding of this if you don&#39;t
want to be in trouble.</p>

<h3>Links and used sources:</h3>

<ul>
<li><a href="http://blog.plataformatec.com.br/tag/eager-load/">Eager loading</a></li>
<li><a href="http://urbanautomaton.com/blog/2013/08/27/rails-autoloading-hell/">Rails autoloading</a></li>
<li><a href="http://tenderlovemaking.com/2012/06/18/removing-config-threadsafe.html">Removing config.threadsafe!</a></li>
</ul>
  <div class='share'>
    <a class="twitter-share-button" data-via="rO_Oute" href="https://twitter.com/share">Tweet</a>
    <script type='text/javascript'>
      //<![CDATA[
        !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
      //]]>
    </script>
  </div>
</article>
      <footer>
        Copyright © 2012-2013
        <a target="_blank" href="https://github.com/route">Dmitry Vorotilin</a>
        |
        <a target="_blank" href="http://route.github.io/cv.html">CV</a>
        |
        <a target="_blank" href="http://evrone.com">Evrone.com</a>
      </footer>
    </div>
  </body>
</html>

