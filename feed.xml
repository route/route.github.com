<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2013-11-12T20:00:00Z</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Rails autoloading</title>
    <link rel="alternate" href="/2013/11/13/rails-autoloading.html"/>
    <id>/2013/11/13/rails-autoloading.html</id>
    <published>2013-11-12T20:00:00Z</published>
    <updated>2013-11-12T20:00:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;h3&gt;How it works&lt;/h3&gt;

&lt;p&gt;There is much to be said about Rails autoloading and particularly about
&lt;code&gt;ActiveSupport::Dependencies&lt;/code&gt; (&lt;code&gt;AS::D&lt;/code&gt; for short). What does it do? As the title
says it loads constants automatically and reloads your code catching changes on&lt;/p&gt;
</summary>
    <content type="html">&lt;h3&gt;How it works&lt;/h3&gt;

&lt;p&gt;There is much to be said about Rails autoloading and particularly about
&lt;code&gt;ActiveSupport::Dependencies&lt;/code&gt; (&lt;code&gt;AS::D&lt;/code&gt; for short). What does it do? As the title
says it loads constants automatically and reloads your code catching changes on
every request. Ok, why do we need it? Because it&amp;#39;s conveniently! We don&amp;#39;t have
to write in every single file &lt;code&gt;require&lt;/code&gt;, watch what constants we need and when.
Rails loads constants and watches what we need automatically. Also there&amp;#39;s no
need to reload your server each time you&amp;#39;ve done a change. There are some
pitfalls that you must know, but when you learn them everything will be ok.&lt;/p&gt;

&lt;p&gt;Previously discussed method &lt;code&gt;self.const_missing(const_name)&lt;/code&gt; is an entry point
where &lt;code&gt;AS::D&lt;/code&gt; starts doing its job. Consider this example:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# /autoloadable/a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;active_support/dependencies&amp;#39;&lt;/span&gt;
  &lt;span class="no"&gt;ActiveSupport&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Dependencies&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;autoload_paths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/autoloadable&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Doing this &lt;code&gt;AS::D&lt;/code&gt; loads module &lt;code&gt;A&lt;/code&gt; automatically without any &lt;code&gt;require&lt;/code&gt;.&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# Meanwhile you can add sleep here and make changes in a.rb&lt;/span&gt;

  &lt;span class="no"&gt;ActiveSupport&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Dependencies&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt; &lt;span class="c1"&gt;# Removes A from memory&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="c1"&gt;# Will load A again&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;I&amp;#39;ve just introduced the method Rails reloads your code with — &lt;code&gt;clear&lt;/code&gt;. Let&amp;#39;s
dig dipper and see how &lt;code&gt;AS::D&lt;/code&gt; actually works. There are two different constant
autoloading schemas by name: &lt;code&gt;:require&lt;/code&gt; and &lt;code&gt;:load&lt;/code&gt;(default). The first one
means that all the constants won&amp;#39;t be reloaded(as eventually &lt;code&gt;require&lt;/code&gt; does, do
you remember &lt;code&gt;$LOADED_FEATURES&lt;/code&gt;?) and the last one means all the constants will
be removed from memory and loaded again on demand. We are talking about such
thing as &amp;#39;removing constant from memory&amp;#39;, it&amp;#39;d be very useful to know how.
There&amp;#39;s a method called &lt;code&gt;Module#remove_const(sym)&lt;/code&gt;:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="no"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:remove_const&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; uninitialized constant A (NameError)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;But what if we remove constant for existed instance of class:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;value&lt;/span&gt;
      &lt;span class="s1"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;
  &lt;span class="no"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:remove_const&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; A&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; &amp;#39;value&amp;#39;&lt;/span&gt;
  &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; uninitialized constant A (NameError)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;That&amp;#39;s interesting because constant name was removed from memory but its
instance still shows us its class and we can even call class methods on it. It
turns out that this method only removes constant name from &lt;code&gt;Object&lt;/code&gt; but the
class as object(do you still remember that class is an object and a constant is
a variable referencing that object?) still exists in the memory. Ok, move on.&lt;/p&gt;

&lt;p&gt;Calling &lt;code&gt;require &amp;#39;active_support/dependencies&amp;#39;&lt;/code&gt; injects a few modules into basic
Ruby classes by mean &lt;code&gt;AS::D.hook!&lt;/code&gt;.&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hook!&lt;/span&gt;
    &lt;span class="no"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_eval&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kp"&gt;include&lt;/span&gt; &lt;span class="no"&gt;Loadable&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="no"&gt;Module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_eval&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kp"&gt;include&lt;/span&gt; &lt;span class="no"&gt;ModuleConstMissing&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="no"&gt;Exception&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_eval&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kp"&gt;include&lt;/span&gt; &lt;span class="no"&gt;Blamable&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Methods injected into &lt;code&gt;Object&lt;/code&gt; overwrite methods like &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; in
order to monitor emerging constants(depends on schema). Another method you could
already know is &lt;code&gt;require_dependency&lt;/code&gt; also injected into &lt;code&gt;Object&lt;/code&gt;. Methods in
&lt;code&gt;Module&lt;/code&gt; define an entry point &lt;code&gt;const_missing&lt;/code&gt; as I told you earlier. I&amp;#39;m gonna
show you how &lt;code&gt;AS::D&lt;/code&gt; works with this example:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# /autoloadable/a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;active_support/dependencies&amp;#39;&lt;/span&gt;
  &lt;span class="no"&gt;ActiveSupport&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Dependencies&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;autoload_paths&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/autoloadable&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;Declaring constant &lt;code&gt;A&lt;/code&gt; triggers &lt;code&gt;Module#const_missing&lt;/code&gt;(was overwritten by
&lt;code&gt;AS::D&lt;/code&gt;) and &lt;code&gt;Dependencies.load_missing_constant(from_mod, const_name)&lt;/code&gt; is
invoked. The first argument is &lt;code&gt;Object&lt;/code&gt; because &lt;code&gt;A == Object::A&lt;/code&gt; the second is
&lt;code&gt;:A&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load_missing_constant&lt;/code&gt; tries to find the path for this constant which is by
convention lies somewhere in one of the &lt;code&gt;autoload_paths&lt;/code&gt; by mean
&lt;code&gt;search_for_file(&amp;#39;a&amp;#39;)&lt;/code&gt;. It just returns the first file it can find with
&lt;code&gt;File.file?(File.join(autoload_path, &amp;#39;a.rb&amp;#39;))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Then method &lt;code&gt;require_or_load&lt;/code&gt; is invoked and it&amp;#39;s behavior depends on schema.
For &lt;code&gt;require&lt;/code&gt; it just requires given file and that&amp;#39;s all, for load
&lt;code&gt;load_file(&amp;#39;/autoloadable/a.rb&amp;#39;, &amp;#39;A&amp;#39;)&lt;/code&gt; is invoked.&lt;/li&gt;
&lt;li&gt;Then it looks for new constants in given namespaces with:
&lt;code&gt;new_constants_in(*parent_paths) { Kernel.load(path) }&lt;/code&gt;
where &lt;code&gt;parent_paths&lt;/code&gt; is &lt;code&gt;[Object]&lt;/code&gt;(we try to resolve &lt;code&gt;Object::A&lt;/code&gt;) and path is
clear I suppose. How does it monitor it? It&amp;#39;s just a difference between array of
constants before and after. &lt;code&gt;Object.local_constants&lt;/code&gt; gives us all the constants
inside &lt;code&gt;Object&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;When it&amp;#39;s done all newly defined constants appends to &lt;code&gt;autoloaded_constants&lt;/code&gt;.
That&amp;#39;s all, new constant was defined with &lt;code&gt;AS::D&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;AS::D.clear&lt;/code&gt; removes constants from memory and clears all auto-loaded constants
inside &lt;code&gt;AS::D&lt;/code&gt;. Pay attention to &lt;code&gt;require_dependency&lt;/code&gt; this method adds all newly
defined constants to &lt;code&gt;autoloaded_constants&lt;/code&gt; so that they will be reloaded unlike
&lt;code&gt;require&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Another convention &lt;code&gt;AS::D&lt;/code&gt; uses is a path convention. This example
&lt;code&gt;&amp;#39;A::B&amp;#39;.underscore # =&amp;gt; &amp;#39;a/b&amp;#39;&lt;/code&gt; simply illustrates that &lt;code&gt;::&lt;/code&gt; treated as a &lt;code&gt;/&lt;/code&gt;,
that gives us ability to use folders like a module namespaces:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# /autoloadable/a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="c1"&gt;# /autoloadable/a/b.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;#   module B&lt;/span&gt;
  &lt;span class="c1"&gt;#     C = &amp;#39;c&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;#   end&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;even this works:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# /autoloadable/a/b.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A::B&lt;/span&gt;
  &lt;span class="c1"&gt;#   C = &amp;#39;c&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Although we haven&amp;#39;t defined module &lt;code&gt;A&lt;/code&gt;, it has been created for us automatically
because of existed directory &lt;code&gt;a&lt;/code&gt;. It&amp;#39;s really conviniently because you don&amp;#39;t
have to create an empty module just for namespace purpose.&lt;/p&gt;

&lt;h3&gt;Misconception&lt;/h3&gt;

&lt;p&gt;Since ruby passes just one argument to &lt;code&gt;const_missing(const_name)&lt;/code&gt; we don&amp;#39;t have
an idea about the nesting, this example works as expected:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# /autoloadable/b.rb&lt;/span&gt;
  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;# /autoloadable/a.rb&lt;/span&gt;
  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; B&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;but:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# /autoloadable/a.rb&lt;/span&gt;
  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;# /autoloadable/b.rb&lt;/span&gt;
  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Is that right? I don&amp;#39;t think so. If we had been used pure ruby it would have
thrown &lt;code&gt;NameError: uninitialized constant A::B&lt;/code&gt;, because we precisely saying we
need &lt;code&gt;B&lt;/code&gt; inside &lt;code&gt;A&lt;/code&gt; but not top level &lt;code&gt;B&lt;/code&gt;. But it&amp;#39;s a ruby blame it passes such
a scant info to &lt;code&gt;const_missing&lt;/code&gt; and &lt;code&gt;AS::D&lt;/code&gt; can do nothing with it.&lt;/p&gt;

&lt;p&gt;Another cool case:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# /autoloadable/a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A; end&lt;/span&gt;

  &lt;span class="c1"&gt;# /autoloadable/namespace/a/b.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module Namespace::A::B&lt;/span&gt;
  &lt;span class="c1"&gt;#  A&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="no"&gt;Namespace&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; What is A?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;What would you expect from this example? I think in Ruby it&amp;#39;s obviously
top-level &lt;code&gt;A&lt;/code&gt;, but since &lt;code&gt;AS::D&lt;/code&gt; doesn&amp;#39;t know nesting info would you expect it
to be either &lt;code&gt;Namespace::A&lt;/code&gt; or &lt;code&gt;A&lt;/code&gt;? Nither, it&amp;#39;s &lt;code&gt;NameError&lt;/code&gt; which is much more
confusing. It&amp;#39;s the last attempt of &lt;code&gt;AS::D&lt;/code&gt; to make an assumption that since
one of our parents has this constant (&lt;code&gt;Namespace.const_defined?(:A, false)&lt;/code&gt;)
then we&amp;#39;re definitely looking for this constant in a short form
&lt;code&gt;from_mod::const_name&lt;/code&gt; otherwise Ruby would return it without calling
&lt;code&gt;const_missing&lt;/code&gt; and we don&amp;#39;t have to search it upwards in &lt;code&gt;from_mod&lt;/code&gt;, but why
don&amp;#39;t we have to search it right at the top level? May be because of this:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# c.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# C = &amp;#39;c&amp;#39;&lt;/span&gt;

  &lt;span class="c1"&gt;# a/c.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;#   C = &amp;#39;ac&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="c1"&gt;# a/b.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A::B&lt;/span&gt;
  &lt;span class="c1"&gt;#   C&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; &amp;#39;ac&amp;#39;&lt;/span&gt;
  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; uninitialized constant A::B::C&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Calling it twice gives us an error, because of the same case we&amp;#39;ve considered
above. The first time &lt;code&gt;AS::D&lt;/code&gt; resolves &lt;code&gt;C&lt;/code&gt; through as usual, but the second time
it starts checking enclosing modules and since &lt;code&gt;A&lt;/code&gt; contains &lt;code&gt;C&lt;/code&gt; then Ruby must
have been resolved it or otherwise it&amp;#39;s the short form and an error is thrown.
Imagine we&amp;#39;ve fixed it and instead of error we start loading top level constant.
Is it any better? Because now we&amp;#39;ve got two different constants in a row, still
sad. Seems like there&amp;#39;s no exit out there until nesting info will not be fixed.&lt;/p&gt;

&lt;h3&gt;Thread safety&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s write our own simplified autoloading:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# autoloadable/a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;#   sleep 5&lt;/span&gt;
  &lt;span class="c1"&gt;#   def self.hello&lt;/span&gt;
  &lt;span class="c1"&gt;#     &amp;#39;hello&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;#   end&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Module&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;const_missing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;./autoloadable/&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="nb"&gt;name&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;downcase&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;.rb&amp;quot;&lt;/span&gt;
      &lt;span class="no"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;const_get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;There result is &lt;code&gt;undefined method &amp;#39;hello&amp;#39; for A:Module (NoMethodError)&lt;/code&gt; Why?
Because second thread takes over when the first is awaiting on sleep. At that
moment module &lt;code&gt;A&lt;/code&gt; already defined but method hello isn&amp;#39;t defined yet. It turns
out that &lt;code&gt;AS::D&lt;/code&gt; will never be thread safe until &lt;code&gt;const_missing&lt;/code&gt; will be thread
safe.&lt;/p&gt;

&lt;h3&gt;Known errors&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Toplevel constant B referenced by A::B&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Have you ever seen the &amp;#39;Toplevel constant B referenced by A::B&amp;#39;? It&amp;#39;s easy to
reproduce even without &lt;code&gt;AS::D&lt;/code&gt;:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Since &lt;code&gt;A.ancestors&lt;/code&gt; is &lt;code&gt;[A, Object, Kernel, BasicObject]&lt;/code&gt; and contains class
&lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; is already defined as a top level constant Ruby shows us
warning that constant we&amp;#39;re trying to resolve inside &lt;code&gt;A&lt;/code&gt; references top level
constant. Notice that for modules the situation is different:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;It gives us just &amp;#39;uninitialized constant A::B (NameError)&amp;#39; because the ancestors
chain doesn&amp;#39;t contain an &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Circular dependency detected while autoloading constant&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is yet another Rails error that you could see:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# /autoloadable/a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# B&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="c1"&gt;# /autoloadable/b.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# A&lt;/span&gt;
  &lt;span class="c1"&gt;# module B&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;If we try to access &lt;code&gt;A&lt;/code&gt; constant we&amp;#39;ll see this error. Rails makes an assumption
that this constant is defined in file &lt;code&gt;a.rb&lt;/code&gt;. When it tries to load this file it
faces another undefined constant &lt;code&gt;B&lt;/code&gt; and this time trying to load file &lt;code&gt;b.rb&lt;/code&gt;
faces again still undefined &lt;code&gt;A&lt;/code&gt;. This generates endless recursion and to prevent
it the error must be raised. This error(and a bunch of others) also appears in
multi threaded environment. Constant autoloading is not thread safe operation,
that&amp;#39;s why your production environment loads all the constants on initialization
step. In fact you can see different errors even on MRI because it switches
threads on IO. For instance circular dependency arises when first thread waits
for IO and another thread starts resolving for the same constant which is
already in a list of loaded.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A copy of &lt;code&gt;A&lt;/code&gt; has been removed from the module tree but is still active!&lt;/li&gt;
&lt;/ul&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# /autoloadable/money.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# class Money&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="c1"&gt;# /autoloadable/customer.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# class Customer&lt;/span&gt;
  &lt;span class="c1"&gt;#   def money&lt;/span&gt;
  &lt;span class="c1"&gt;#     Money.new&lt;/span&gt;
  &lt;span class="c1"&gt;#   end&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="n"&gt;customer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Customer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;

  &lt;span class="no"&gt;ActiveSupport&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Dependencies&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;

  &lt;span class="n"&gt;customer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;money&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;It happens because class for Customer was autoloaded, but class for Money wasn&amp;#39;t
because we haven&amp;#39;t invoked &lt;code&gt;Money.new&lt;/code&gt; until &lt;code&gt;AS::D.clear&lt;/code&gt;. Then &lt;code&gt;Customer&lt;/code&gt; was
removed as a reference but instance of this class still in memory, and then
we&amp;#39;re trying to resolve constant name Money, but for &lt;code&gt;customer.class::Money&lt;/code&gt;
which is different from newly loaded &lt;code&gt;Customer&lt;/code&gt;. Please be afraid of saving the
whole instance somewhere between sessions, otherwise chances you&amp;#39;ll see this are
bigger.&lt;/p&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;You don&amp;#39;t have to care about all these stuff if you have flat model, it means
when you don&amp;#39;t use namespaces and all the files have different names, but it&amp;#39;s
hard if you have a lot of classes/modules. So you must have clear understanding
of this if you don&amp;#39;t want to be in trouble.&lt;/p&gt;

&lt;h3&gt;Links and used sources:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.plataformatec.com.br/tag/eager-load/"&gt;Eager loading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://urbanautomaton.com/blog/2013/08/27/rails-autoloading-hell/"&gt;Rails autoloading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tenderlovemaking.com/2012/06/18/removing-config-threadsafe.html"&gt;Removing config.threadsafe!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ruby loading and requiring files, constant name resolution</title>
    <link rel="alternate" href="/2013/11/05/ruby-loading-and-requiring-files-constant-name-resolution.html"/>
    <id>/2013/11/05/ruby-loading-and-requiring-files-constant-name-resolution.html</id>
    <published>2013-11-04T20:00:00Z</published>
    <updated>2013-11-04T20:00:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;This article has started as my own research on a slightly different theme —
&lt;a href="/2013/11/13/rails-autoloading.html"&gt;Rails autoloading&lt;/a&gt;, but I couldn&amp;#39;t describe
it without saying a single word about Ruby itself. In this topic we&amp;#39;ll talk
about how Ruby loads and requires modules, constant name resolution and then&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;This article has started as my own research on a slightly different theme —
&lt;a href="/2013/11/13/rails-autoloading.html"&gt;Rails autoloading&lt;/a&gt;, but I couldn&amp;#39;t describe
it without saying a single word about Ruby itself. In this topic we&amp;#39;ll talk
about how Ruby loads and requires modules, constant name resolution and then
we&amp;#39;ll switch to &lt;a href="/2013/11/13/rails-autoloading.html"&gt;Rails autoloading&lt;/a&gt;. There&amp;#39;s
more or less info about all these topics on the internet, so that sometimes I&amp;#39;ll
be overlapping with it but sometimes not, I don&amp;#39;t claim it&amp;#39;s unique info but
anyway I have to sum it up in just one big article. So let&amp;#39;s get started with
Ruby.&lt;/p&gt;

&lt;h3&gt;Constant definition:&lt;/h3&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;A constant in Ruby is like a variable, except that its value is supposed to
remain constant for the duration of a program. The Ruby interpreter does not
actually enforce the constancy of constants, but it does issue a warning if a
program changes the value of a constant. Lexically, the names of constants look
like the names of local variables, except that they begin with a capital letter.
By convention, most constants are written in all uppercase with underscores to
separate words, LIKE_THIS. Ruby class and module names are also constants, but
they are conventionally written using initial capital letters and camel case,
LikeThis.

The Ruby Programming Language: David Flanagan; Yukihiro Matsumoto.
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;I think it&amp;#39;s clear and turns out that we&amp;#39;ll see a warning if we&amp;#39;ll try to change
a constant:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
  &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;#./a.rb:2: warning: already initialized constant A&lt;/span&gt;
  &lt;span class="c1"&gt;#./a.rb:1: warning: previous definition of A was here&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;The same thing for classes:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;#./a.rb:2: warning: already initialized constant A&lt;/span&gt;
  &lt;span class="c1"&gt;#./a.rb:1: warning: previous definition of A was here&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Since the constant &lt;code&gt;A&lt;/code&gt; is just a reference for the class&amp;#39; object (remember class
is object in Ruby, right?) and we try to reassign it with new value then we see
this warning. Ok, now we know what the constant is, moving to files requiring.&lt;/p&gt;

&lt;h3&gt;Loading and requiring files&lt;/h3&gt;

&lt;p&gt;We cannot place all the code in just one single file, otherwise it would be too
long and complicated for reading. Usually we put a class per file and use a few
different methods in order to &amp;#39;concatenate&amp;#39; it. Here they are: &lt;code&gt;require&lt;/code&gt;,
&lt;code&gt;require_relative&lt;/code&gt;, &lt;code&gt;load&lt;/code&gt;, &lt;code&gt;autoload&lt;/code&gt;. Let&amp;#39;s start with the first one.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Kernel#require(name)&lt;/code&gt; loads the given name, returning &lt;code&gt;true&lt;/code&gt; if successful and
&lt;code&gt;false&lt;/code&gt; if the feature is already loaded. If the filename does not resolve to an
absolute path, it will be searched for in the directories listed in
&lt;code&gt;$LOAD_PATH ($:)&lt;/code&gt;. Any constants or globals within the loaded source file will
be available in the calling program&amp;#39;s global namespace. However, local variables
will not be propagated to the loading environment. With this method you can load
even native extension(&lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dll&lt;/code&gt; or the others depending on current
platform). If you don&amp;#39;t specify the extension Ruby starts with &lt;code&gt;.rb&lt;/code&gt; and so on.
The absolute path of the loaded file is added to &lt;code&gt;$LOADED_FEATURES ($&amp;quot;)&lt;/code&gt;. A file
will not be loaded again if its path already appears in &lt;code&gt;$&amp;quot;&lt;/code&gt;.
&lt;code&gt;Kernel.require_relative(name)&lt;/code&gt; is almost the same as &lt;code&gt;require&lt;/code&gt; but it looks for
a file in the current directory or directories that is relative to current.&lt;/p&gt;

&lt;p&gt;Example with &lt;code&gt;require&lt;/code&gt;:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;#   C = &amp;#39;constant&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="vg"&gt;$&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dup&lt;/span&gt;
  &lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
  &lt;span class="vg"&gt;$&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; [&amp;#39;/Users/route/Projects/dependencies/a.rb&amp;#39;]&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; &amp;#39;constant&amp;#39;&lt;/span&gt;
  &lt;span class="nb"&gt;sleep&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="c1"&gt;# Meanwhile changing constant value to &amp;#39;changed&amp;#39;&lt;/span&gt;

  &lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; &amp;#39;constant&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Kernel#load(filename, wrap=false)&lt;/code&gt; loads and executes the Ruby program in the
filename. If the filename does not resolve to an absolute path, the file is
searched for in &lt;code&gt;$:&lt;/code&gt;. If the optional wrap parameter is true, the loaded script
will be executed under an anonymous module, protecting the calling program&amp;#39;s
global namespace. It also can load the content of file many times because it
doesn&amp;#39;t rely on &lt;code&gt;$LOADED_FEATURES&lt;/code&gt;. Notice that &lt;code&gt;load&lt;/code&gt; needs a filename
extension.&lt;/p&gt;

&lt;p&gt;Example with &lt;code&gt;load&lt;/code&gt;:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;#   C = &amp;#39;constant&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="vg"&gt;$&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dup&lt;/span&gt;
  &lt;span class="nb"&gt;load&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;./a.rb&amp;#39;&lt;/span&gt;
  &lt;span class="vg"&gt;$&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; []&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; &amp;#39;constant&amp;#39;&lt;/span&gt;
  &lt;span class="nb"&gt;sleep&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
  &lt;span class="c1"&gt;# Meanwhile changing constant value to &amp;#39;changed&amp;#39;&lt;/span&gt;

  &lt;span class="nb"&gt;load&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;./a.rb&amp;#39;&lt;/span&gt;

  &lt;span class="c1"&gt;# ./a.rb:2: warning: already initialized constant A::C&lt;/span&gt;
  &lt;span class="c1"&gt;# ./a.rb:2: warning: previous definition of C was here&lt;/span&gt;
  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; &amp;#39;changed&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;With warnings but the code was reloaded and we can even see the changes we&amp;#39;ve
made. Let&amp;#39;s add optional parameter &lt;code&gt;wrap&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;Example with &lt;code&gt;load&lt;/code&gt; and wrap:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;#   C = &amp;#39;constant&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;
  &lt;span class="c1"&gt;#&lt;/span&gt;
  &lt;span class="c1"&gt;# $A = A&lt;/span&gt;

  &lt;span class="nb"&gt;load&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;./a.rb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;

  &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; uninitialized constant A (NameError)&lt;/span&gt;
  &lt;span class="vg"&gt;$A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; &amp;#39;constant&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;You see that Ruby hasn&amp;#39;t polluted global namespace and wrapped all the constants
from the file to an anonymous module, but global variables still could be
retrieved.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Kernel#autoload(module, filename)&lt;/code&gt; registers filename to be loaded (using
&lt;code&gt;Kernel::require&lt;/code&gt;) the first time that module (&lt;code&gt;String&lt;/code&gt; or a &lt;code&gt;Symbol&lt;/code&gt;) is
accessed.&lt;/p&gt;

&lt;p&gt;Example 1 with &lt;code&gt;autoload&lt;/code&gt;:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;#   p &amp;#39;loading&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="nb"&gt;autoload&lt;/span&gt; &lt;span class="ss"&gt;:A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;It won&amp;#39;t produce anything useful, because we&amp;#39;ve just declared that constant &lt;code&gt;A&lt;/code&gt;
can be found in a file but we&amp;#39;ve never used it.&lt;/p&gt;

&lt;p&gt;Example 2 with &lt;code&gt;autoload&lt;/code&gt;:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;#   p &amp;#39;loading&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="nb"&gt;autoload&lt;/span&gt; &lt;span class="ss"&gt;:A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
  &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; Gives output &amp;#39;loading&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;In other words &lt;code&gt;autoload&lt;/code&gt; makes us to load code lazily on demand decreasing time
during the boot. There were some problems with thread safety and &lt;code&gt;autoload&lt;/code&gt;,
also there was a rumor that it would be deprecated, but I hadn&amp;#39;t found any info
what the Ruby core team came up with. But the bug was fixed and I just can say
it works properly even with threads for now:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;# a.rb&lt;/span&gt;
  &lt;span class="c1"&gt;# module A&lt;/span&gt;
  &lt;span class="c1"&gt;#   sleep 5&lt;/span&gt;
  &lt;span class="c1"&gt;#   def self.hello&lt;/span&gt;
  &lt;span class="c1"&gt;#     &amp;#39;hello&amp;#39;&lt;/span&gt;
  &lt;span class="c1"&gt;#   end&lt;/span&gt;
  &lt;span class="c1"&gt;# end&lt;/span&gt;

  &lt;span class="nb"&gt;autoload&lt;/span&gt; &lt;span class="ss"&gt;:A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;./a&amp;#39;&lt;/span&gt;

  &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;I was expecting that second thread would throw an error that method &lt;code&gt;hello&lt;/code&gt; is
undefined because module &lt;code&gt;A&lt;/code&gt; had been loaded by first thread but because of
sleep threads were switched, but it worked.&lt;/p&gt;

&lt;h3&gt;Constant resolution&lt;/h3&gt;

&lt;p&gt;I find this example very comprehensive and I won&amp;#39;t describe it much because the
code tells about itself:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;Kernel&lt;/span&gt;
    &lt;span class="c1"&gt;# Constants defined in Kernel&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;defined in kernel&amp;#39;&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="c1"&gt;# Top-level or &amp;#39;global&amp;#39; constants defined in Object&lt;/span&gt;
  &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;defined at top-level&amp;#39;&lt;/span&gt;

  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Super&lt;/span&gt;
    &lt;span class="c1"&gt;# Constants defined in a superclass&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;defined in superclass&amp;#39;&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;Included&lt;/span&gt;
    &lt;span class="c1"&gt;# Constants defined in an included module&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;defined in included module&amp;#39;&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;Enclosing&lt;/span&gt;
    &lt;span class="c1"&gt;# Constants defined in an enclosing module&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;defined in enclosing module&amp;#39;&lt;/span&gt;

    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Local&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;Super&lt;/span&gt;
      &lt;span class="kp"&gt;include&lt;/span&gt; &lt;span class="no"&gt;Included&lt;/span&gt;

      &lt;span class="c1"&gt;# Locally defined constant&lt;/span&gt;
      &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;defined locally&amp;#39;&lt;/span&gt;

      &lt;span class="c1"&gt;# The list of modules searched, in the order searched&lt;/span&gt;
      &lt;span class="c1"&gt;# [Enclosing::Local, Enclosing, Included, Super, Object, Kernel, BasicObject]&lt;/span&gt;
      &lt;span class="c1"&gt;# (Module.nesting + self.ancestors + Object.ancestors).uniq&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;  &lt;span class="c1"&gt;# Prints &amp;quot;defined locally&amp;quot;&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;  &lt;span class="c1"&gt;# Prints &amp;quot;defined in enclosing module&amp;quot;&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;  &lt;span class="c1"&gt;# Prints &amp;quot;defined in included module&amp;quot;&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;  &lt;span class="c1"&gt;# Prints &amp;quot;defined in superclass&amp;quot;&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;  &lt;span class="c1"&gt;# Prints &amp;quot;defined at top-level&amp;quot;&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;  &lt;span class="c1"&gt;# Prints &amp;quot;defined in kernel&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;So the path Ruby follows in order to resolve constant name starts with
&lt;code&gt;Module.nesting&lt;/code&gt; which of course starts with itself and then all enclosing
constants respectively. If the constant cannot be found there, then ancestors
chain is applied.&lt;/p&gt;

&lt;h3&gt;Known pitfalls:&lt;/h3&gt;

&lt;p&gt;1) Nesting:&lt;/p&gt;

&lt;p&gt;We can define new class/module using two different ways:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A::B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Pay attention that &lt;code&gt;Module.nesting&lt;/code&gt; for these two forms is different and turns
out that your constant name resolution will be different too:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A&lt;/span&gt;
    &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;
      &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; &amp;#39;c&amp;#39;&lt;/span&gt;
      &lt;span class="no"&gt;Module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nesting&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; [A::B, A]&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A::B&lt;/span&gt;
    &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; NameError: uninitialized constant A::B::C&lt;/span&gt;
    &lt;span class="no"&gt;Module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nesting&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; [A::B]&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;2) Inheritance:&lt;/p&gt;

&lt;p&gt;Remember that constants use the currently opened class or module, as determined
by &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;module&lt;/code&gt; statements.&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Parent&lt;/span&gt;
    &lt;span class="no"&gt;CONST&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;parent&amp;#39;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;const&lt;/span&gt;
      &lt;span class="no"&gt;CONST&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Child&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;Parent&lt;/span&gt;
    &lt;span class="no"&gt;CONST&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;child&amp;#39;&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="no"&gt;Child&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; parent&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;In this example method is invoked on parent class, so its class is the innermost
one. To change things you could use &lt;code&gt;self::CONST&lt;/code&gt; this way you&amp;#39;re explicitly
saying find my constant in &lt;code&gt;self&lt;/code&gt; where &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Child&lt;/code&gt; if we call
&lt;code&gt;Child.const&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;3) Object::&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Module.nesting == []&lt;/code&gt; at the top level, and so constant lookup starts at the
currently opened class and its ancestors which is &lt;code&gt;Object&lt;/code&gt;:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Object&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="no"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="no"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;This in turn explains why top-level constants are available throughout your
program. Almost all classes in Ruby inherit from &lt;code&gt;Object&lt;/code&gt;, so &lt;code&gt;Object&lt;/code&gt; is almost
always included in the list of ancestors of the currently open class, and thus
its constants are almost always available. That said, if you&amp;#39;ve ever used a
&lt;code&gt;BasicObject&lt;/code&gt;, and noticed that top-level constants are missing, you now know
why. Because &lt;code&gt;BasicObject&lt;/code&gt; does not subclass &lt;code&gt;Object&lt;/code&gt;, all of the constants are
not in the lookup chain:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;BasicObject&lt;/span&gt;
    &lt;span class="no"&gt;Kernel&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="c1"&gt;# NameError: uninitialized constant Foo::Kernel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;For cases like this, and anywhere else you want to be explicit, Ruby allows you
to use &lt;code&gt;::Kernel&lt;/code&gt; to access &lt;code&gt;Object::Kernel&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;4) &lt;code&gt;class_eval&lt;/code&gt;, &lt;code&gt;module_eval&lt;/code&gt;, &lt;code&gt;instance_eval&lt;/code&gt;, &lt;code&gt;define_method&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;As mentioned above, constant lookup uses the currently opened class, as
determined by class and module statements. Importantly, if you pass a block into
&lt;code&gt;class_eval&lt;/code&gt;, &lt;code&gt;module_eval&lt;/code&gt; or &lt;code&gt;instance_eval&lt;/code&gt;, &lt;code&gt;define_method&lt;/code&gt;, this won&amp;#39;t
change constant lookup. It continues to use the constant lookup at the
point the block was defined:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;C&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_eval&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Confusingly however, if you pass a &lt;code&gt;String&lt;/code&gt; to these methods, then the &lt;code&gt;String&lt;/code&gt;
is evaluated with &lt;code&gt;Module.nesting&lt;/code&gt; containing just the class/module itself (for
&lt;code&gt;class_eval&lt;/code&gt; or &lt;code&gt;module_eval&lt;/code&gt;) or just the singleton class of the object (for
&lt;code&gt;instance_eval&lt;/code&gt;).&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;C&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;module_eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;B&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;A&lt;/span&gt;
    &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;C&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;module_eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;X&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; uninitialized constant A::B::X (NameError)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;5) Singleton class:&lt;/p&gt;

&lt;p&gt;If you&amp;#39;re in a singleton class of a class, you don&amp;#39;t get access to constants
defined in the class itself:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; uninitialized constant Class::B&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;This is because the ancestors of the singleton class of a class do not include
the class itself, they start at the &lt;code&gt;Class&lt;/code&gt; class.&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;
    &lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;
    &lt;span class="nb"&gt;ancestors&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; [Class, Module, Object, Kernel, BasicObject]&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Lastly, imagine we access a constant that isn&amp;#39;t defined at all then
&lt;code&gt;self.const_missing&lt;/code&gt; is invoked on the class that needs constant or if it wasn&amp;#39;t
defined on that class it&amp;#39;s invoked on its superclass — &lt;code&gt;Module&lt;/code&gt;
(&lt;code&gt;A.class.superclass # =&amp;gt; Module&lt;/code&gt;). It accepts just one single argument
&lt;code&gt;const_name&lt;/code&gt; which is the constant name we&amp;#39;re looking for. By default this
method simply throws an error &lt;code&gt;NameError: uninitialized constant #{const_name}&lt;/code&gt;.
That&amp;#39;s all for Ruby moving to the more interesting part —
&lt;a href="/2013/11/13/rails-autoloading.html"&gt;Rails autoloading&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Links and used sources:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://ruby-doc.org"&gt;Ruby-doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cirw.in/blog/constant-lookup"&gt;Constant lookup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://coderrr.wordpress.com/2008/03/11/constant-name-resolution-in-ruby/"&gt;Module.nesting and constant name resolution in Ruby&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Ruby inherited method bug</title>
    <link rel="alternate" href="/2012/12/16/ruby-inherited-method-bug.html"/>
    <id>/2012/12/16/ruby-inherited-method-bug.html</id>
    <published>2012-12-15T20:00:00Z</published>
    <updated>2012-12-15T20:00:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;This post is about the bug I found when I was writing tests for &lt;code&gt;quiet_assets&lt;/code&gt;.
I won&amp;#39;t show you all those tests, just a small piece:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="no"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Rails&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Application&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;routes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;.&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;All of them were passed on my laptop, but Travis-CI showed me the odd message&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;This post is about the bug I found when I was writing tests for &lt;code&gt;quiet_assets&lt;/code&gt;.
I won&amp;#39;t show you all those tests, just a small piece:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="no"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Rails&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Application&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;routes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;.&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;All of them were passed on my laptop, but Travis-CI showed me the odd message
for Ruby 1.8:
&lt;code&gt;undefined local variable or method &amp;#39;routes&amp;#39; for #&amp;lt;Class:0xb6b9a92c&amp;gt;&lt;/code&gt;.
It says that there&amp;#39;s no such method &lt;code&gt;routes&lt;/code&gt; inside dynamically generated class,
but it works for Ruby 1.9. What&amp;#39;s wrong with it? Let&amp;#39;s take a look at
Rails core. In our example we define dynamic class whose parent is
&lt;code&gt;Rails::Application&lt;/code&gt; that inherited from class &lt;code&gt;Rails::Engine&lt;/code&gt; that inherited
from &lt;code&gt;Rails::Railtie&lt;/code&gt;. You can find &lt;code&gt;routes&lt;/code&gt; definition at line 488 of
&lt;code&gt;Rails::Engine&lt;/code&gt;. I consider only 3-2-stable branch in my post. It&amp;#39;s defined as
an instance method. How can it be possible to use it on the class level?
If you take a look at the chain of &lt;code&gt;self.inherited&lt;/code&gt; callbacks in all those
classes you&amp;#39;ll see that &lt;code&gt;Rails::Railtie&lt;/code&gt; has module inclusion:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inherited&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;.&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
    &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:include&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;Railtie&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Configurable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Railtie::Configurable&lt;/code&gt; has &lt;code&gt;method_missing&lt;/code&gt; which does exactly our case -
proxying our calls to instance. You see that all logic rely on &lt;code&gt;self.inhereted&lt;/code&gt;
callback. Let&amp;#39;s check it:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Parent&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;inherited&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Inside inherited&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Child&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;Parent&lt;/span&gt;
    &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;We are inside class definition&amp;#39;&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;Parent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;We are inside class definition&amp;#39;&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;If you run this code you&amp;#39;ll see that for &lt;code&gt;Class.new&lt;/code&gt; we&amp;#39;ll get this:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;We&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;inside&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;definition&lt;/span&gt;
  &lt;span class="n"&gt;Inside&lt;/span&gt; &lt;span class="n"&gt;inherited&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Ruby 1.8 cannot find &lt;code&gt;routes&lt;/code&gt;, even &lt;code&gt;method_missing&lt;/code&gt; just because
&lt;code&gt;self.inherited&lt;/code&gt; chain couldn&amp;#39;t be invoked inside our block, it would be
invoked after class definition. Be careful!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>See the difference</title>
    <link rel="alternate" href="/2012/08/28/see-the-difference.html"/>
    <id>/2012/08/28/see-the-difference.html</id>
    <published>2012-08-27T20:00:00Z</published>
    <updated>2012-08-27T20:00:00Z</updated>
    <author>
      <name>Article Author</name>
    </author>
    <summary type="html">&lt;p&gt;Yesterday I faced the strange behaviour of the array wrapping in context
of Arel. I tried to wrap something like this &lt;code&gt;User.arel_table[:id]&lt;/code&gt; but
&lt;code&gt;Array(User.arel_table[:id])&lt;/code&gt; and &lt;code&gt;Array.wrap(User.arel_table[:id])&lt;/code&gt;
gave me different results. Now I&amp;#39;ll tell you why you have to know about&lt;/p&gt;
</summary>
    <content type="html">&lt;p&gt;Yesterday I faced the strange behaviour of the array wrapping in context
of Arel. I tried to wrap something like this &lt;code&gt;User.arel_table[:id]&lt;/code&gt; but
&lt;code&gt;Array(User.arel_table[:id])&lt;/code&gt; and &lt;code&gt;Array.wrap(User.arel_table[:id])&lt;/code&gt;
gave me different results. Now I&amp;#39;ll tell you why you have to know about
some differences in array wrapping and why Rails contains their own wrap
realization.&lt;/p&gt;

&lt;p&gt;You probably know about
&lt;a href="https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/array/wrap.rb#L36"&gt;Array.wrap&lt;/a&gt;
in Rails but if you don&amp;#39;t here you are:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;wrap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nil?&lt;/span&gt;
      &lt;span class="o"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;elsif&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;respond_to?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:to_ary&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_ary&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;And you probably know about
&lt;a href="http://rxr.whitequark.org/mri/source/object.c#2624"&gt;Kernel#Array&lt;/a&gt;:&lt;/p&gt;
&lt;div class='codeblock'&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;VALUE&lt;/span&gt;
  &lt;span class="nf"&gt;rb_Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;VALUE&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;VALUE&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rb_check_array_type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NIL_P&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rb_check_convert_type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T_ARRAY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Array&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;to_a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NIL_P&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rb_ary_new3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;VALUE&lt;/span&gt;
  &lt;span class="nf"&gt;rb_f_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;VALUE&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;VALUE&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rb_Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;#39;s talk about ruby realization first of all.
When you invoke &lt;code&gt;Array(object)&lt;/code&gt;, ruby will try to convert object into array
by means of &lt;code&gt;rb_check_array_type(val)&lt;/code&gt; call. At the first step this
function will try to invoke &lt;code&gt;to_ary&lt;/code&gt; and if it&amp;#39;s defined and result differ
from &lt;code&gt;nil&lt;/code&gt; and the same class as and &lt;code&gt;Array&lt;/code&gt; it&amp;#39;ll be returned.
The second step (Line 6) (if result of the first step was &lt;code&gt;nil&lt;/code&gt;)
is &lt;code&gt;to_a&lt;/code&gt;, here is the same thing as described above. The third and final
step (Line 8) (if steps above return &lt;code&gt;nil&lt;/code&gt;) is new array will be created
with object as its element.&lt;/p&gt;

&lt;p&gt;Now take a look at Rails realization. If object is &lt;code&gt;nil&lt;/code&gt; it returns empty
array. If object responds to &lt;code&gt;to_ary&lt;/code&gt; method it returns the result
or if the result is &lt;code&gt;nil&lt;/code&gt; just &lt;code&gt;[object]&lt;/code&gt;. And finally it returns 
&lt;code&gt;[object]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You see that Rails method doesn&amp;#39;t call &lt;code&gt;to_a&lt;/code&gt;.
And one thing I haven&amp;#39;t mentioned is raise. Yep. Ruby version will raise
exception if object that you return in &lt;code&gt;to_ary&lt;/code&gt; or &lt;code&gt;to_a&lt;/code&gt; methods isn&amp;#39;t
&lt;code&gt;Array&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now you and me know why &lt;code&gt;Array(object)&lt;/code&gt; returns me not what I wanted
because of overridden &lt;code&gt;to_a&lt;/code&gt; method in Arel.
And in my case I select Rails version of course.&lt;/p&gt;

&lt;p&gt;There are things I have never thought about and just used them.
They seemed to me very simple but in reality they are tiniest bits of a big
complicated mechanism. We use too many abstraction levels and work on the top
of it and rely on it. You should be waiting for troubles from everywhere.&lt;/p&gt;
</content>
  </entry>
</feed>
